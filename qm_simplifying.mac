/* implement bra, ket operators via simplification */

simp: false; /* do not simplify while defining rules */

/* bra and ket consider multiple arguments as a list */

matchdeclare ([aa, bb, cc], all);

tellsimpafter (bra (aa, bb), bra ([aa, bb]));

tellsimpafter (ket (aa, bb), ket ([aa, bb]));

tellsimpafter (bra (aa, bb, cc), bra ([aa, bb, cc]));

tellsimpafter (ket (aa, bb, cc), ket ([aa, bb, cc]));

/* bra and ket of a list represented as row and column matrices, respectively */

qm_simplifying_bra_ket_list_to_matrix: true;

matchdeclare (ll, lambda ([e], qm_simplifying_bra_ket_list_to_matrix and listp(e)));

tellsimpafter (bra (ll), conjugate (matrix (ll)));

tellsimpafter (ket (ll), transpose (matrix (ll)));

/* contract bra(a) . ket(b) to braket(a, b) */

tellsimpafter (bra (aa) . ket (bb), braket (bra (aa), ket (bb)));

tellsimpafter (ket (aa) . ket (bb), braket (dagger (ket (aa)), ket (bb)));

matchdeclare ([mm1, mm2], matrixp);

tellsimpafter (braket (mm1, mm2), mm1 . mm2);

/* same rules for subscripted bra and ket */

tellsimpafter (bra[j, m] (aa, bb) . ket[j, m] (cc, dd), braket (bra[j, m](aa, bb), ket[j, m](cc, dd)));

tellsimpafter (ket[j, m] (aa, bb) . ket[j, m] (cc, dd), braket (dagger (ket[j, m](aa, bb)), ket[j, m](cc, dd)));

matchdeclare ([ii, jj, kk, nn], numberp);

tellsimpafter (braket (bra[j, m](ii, jj), ket[j, m](kk, nn)), kron_delta (kk, ii)*kron_delta (nn, jj));

/* dagger exchanges bra and ket */

tellsimpafter (dagger (bra (aa)), ket (aa));

tellsimpafter (dagger (ket (aa)), bra (aa));

/* special case of dagger for matrix argument */

matchdeclare (mm, matrixp);

tellsimpafter (dagger (mm), conjugate (transpose (mm)));

/* norm defined in terms of bra and ket */

tellsimpafter (norm (aa), sqrt (bra (aa) . ket (aa)));

/* square of the magnitude of a complex number */

tellsimpafter (magsqr (aa), aa * conjugate (aa));

simp: true; /* re-enable simplification */
